"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var flatted = require('flatted');

var levels = require('./levels');

var moment = require('moment');
/**
 * @name LoggingEvent
 * @namespace Log4js
 */


var LoggingEvent =
/*#__PURE__*/
function () {
  /**
   * Models a logging event.
   * @constructor
   * @param {string} categoryName name of category
   * @param {Log4js.Level} level level of message
   * @param {Array} data objects to log
   * @author Seth Chisamore
   */
  function LoggingEvent(categoryName, level, data, context, location) {
    _classCallCheck(this, LoggingEvent);

    this.startTime = moment().format('DD-MMM-YYYY hh:mm:ss A');
    this.categoryName = categoryName;
    this.data = data;
    this.level = level;
    this.context = Object.assign({}, context);
    this.pid = process.pid;

    if (location) {
      this.functionName = location.functionName;
      this.fileName = location.fileName;
      this.lineNumber = location.lineNumber;
      this.columnNumber = location.columnNumber;
      this.callStack = location.callStack;
    }
  }

  _createClass(LoggingEvent, [{
    key: "serialise",
    value: function serialise() {
      var logData = this.data.map(function (e) {
        // JSON.stringify(new Error('test')) returns {}, which is not really useful for us.
        // The following allows us to serialize errors correctly.
        if (e && e.message && e.stack) {
          e = Object.assign({
            message: e.message,
            stack: e.stack
          }, e);
        }

        return e;
      });
      this.data = logData;
      return flatted.stringify(this);
    }
  }], [{
    key: "deserialise",
    value: function deserialise(serialised) {
      var event;

      try {
        var rehydratedEvent = flatted.parse(serialised);
        rehydratedEvent.data = rehydratedEvent.data.map(function (e) {
          if (e && e.message && e.stack) {
            var fakeError = new Error(e);
            Object.keys(e).forEach(function (key) {
              fakeError[key] = e[key];
            });
            e = fakeError;
          }

          return e;
        });
        event = new LoggingEvent(rehydratedEvent.categoryName, levels.getLevel(rehydratedEvent.level.levelStr), rehydratedEvent.data, rehydratedEvent.context);
        event.startTime = new Date(rehydratedEvent.startTime);
        event.pid = rehydratedEvent.pid;
        event.cluster = rehydratedEvent.cluster;
      } catch (e) {
        event = new LoggingEvent('log4js', levels.ERROR, ['Unable to parse log:', serialised, 'because: ', e]);
      }

      return event;
    }
  }]);

  return LoggingEvent;
}();

module.exports = LoggingEvent;